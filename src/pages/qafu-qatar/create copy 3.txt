/* eslint-disable @next/next/no-img-element */
import React, { useRef, useState } from "react";
import type { NextPage, GetStaticProps, InferGetStaticPropsType } from "next";
import { useRouter } from 'next/router'
import { FileUploader } from "react-drag-drop-files";

import { useTranslation } from "next-i18next";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";
import {
  ThirdwebNftMedia,
  useAddress,
  useDisconnect,
  useMetamask,
  useNetwork,
  useNetworkMismatch,
  useContract,
  useNFTs,
  useSDK,
  useSigner,
  useStorageUpload,
  Web3Button
} from "@thirdweb-dev/react";
import { ChainId, NATIVE_TOKEN_ADDRESS } from "@thirdweb-dev/sdk";
import { SmartContract } from "@thirdweb-dev/sdk";

type Props = {
  // Add custom props here
}

const Create = (_props: InferGetStaticPropsType<typeof getStaticProps>) => {

  // Translations
  const t = useTranslation('common');

  const router = useRouter();

  // ------------

  const address = useAddress();
  const { mutateAsync: upload } = useStorageUpload();

  // Fetch the NFT collection from thirdweb via it's contract address.
  const { contract: nftCollection } = useContract(process.env.NEXT_PUBLIC_COLLECTION_QAFU_ADDRESS, "nft-collection");
  const { contract: marketplace } = useContract(process.env.NEXT_PUBLIC_MARKETPLACE_CONTRACT_ADDRESS, "marketplace");

  // Here we store the user inputs for their NFT.
  const [nftName, setNftName] = useState<string>("");
  const [file, setFile] = useState<File>();

  const { data: nfts, isLoading: loadingNfts } = useNFTs(nftCollection);

  // Magic to get the file upload even though its hidden
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  // Function to store file in state when user uploads it
  const uploadFile = () => {
    if (fileInputRef?.current) {
      fileInputRef.current.click();

      fileInputRef.current.onchange = () => {
        if (fileInputRef?.current?.files?.length) {
          const file = fileInputRef.current.files[0];
          setFile(file);
        }
      };
    }
  };

  // Hooks to detect user is on the right network and switch them if they are not
  const networkMismatch = useNetworkMismatch();
  const [, switchNetwork] = useNetwork();
  const sdk = useSDK();


  // This function calls a Next JS API route that mints an NFT with signature-based minting.
  // We send in the address of the current user, and the text they entered as part of the request.
  // const mintWithSignature = async () => {
  async function handleCreateListing(e: any) {
    try {

      // Prevent page from refreshing
      e.preventDefault();

      // nftName = e.target.name.value;
      if (!file || !e.target.name.value) {
        alert("Please enter a name and upload a file.");
        return;
      }

      // Ensure user is on the correct network
      if (networkMismatch) {
        switchNetwork?.(ChainId.Mumbai);
        return;
      }

      // Upload image to IPFS using Storage
      const uris = await upload({
        data: [file],
      });

      // Make a request to /api/server
      const signedPayloadReq = await fetch(`/api/qafu-generate-mint-signature`, {
        method: "POST",
        body: JSON.stringify({
          authorAddress: address, // Address of the current user
          nftName: e.target.elements.name.value,
          description: e.target.elements.description.value,
          imagePath: uris[0],
        }),
      });

      // Grab the JSON from the response
      const json = await signedPayloadReq.json();

      if (!signedPayloadReq.ok) {
        alert(json.error);
      }

      // If the request succeeded, we'll get the signed payload from the response.
      // The API should come back with a JSON object containing a field called signedPayload.
      // This line of code will parse the response and store it in a variable called signedPayload.
      const signedPayload = json.signedPayload;

      // Now we can call signature.mint and pass in the signed payload that we received from the server.
      // This means we provided a signature for the user to mint an NFT with.
      const nft = await nftCollection?.signature.mint(signedPayload);

      const mintedTokenId = nft?.id.toNumber();
      console.log({
        mintedTokenId: mintedTokenId
      });

      // Store the result of either the direct listing creation or the auction listing creation
      let transactionResult = undefined;

      console.log("Done");

      alert("Minted succesfully!");

      //return nft;
    } catch (e) {
      console.error("An error occurred trying to mint the NFT:", e);
    }
  };

  // ------

  

  // File upload
  const fileTypes = [
    "JPG",
    "PNG",
    "GIF",
    "SVG",
    "MP4",
    "WEBM",
    "MP3",
    "WAV",
    "OGG",
    "GLB",
    "GLTF",
  ];
  // const fileInputRef = useRef(null);
  // const [file, setFile] = useState();
  const handleFileChange = (file: any) => {
    setFile(file);
  };



  // Properties
  const [name, setName] = useState();
  const [desc, setDesc] = useState();

  // Mint






  // This function gets called when the form is submitted.
  async function handleCreateListing2(e: any) {
    // setCreatingListing(true);
    try {
      // Prevent page from refreshing
      e.preventDefault();

      // De-construct data from form submission
      //istingType,
      const { name, description, price } = e.target.elements;

      console.log({
        // listingType: listingType.value,
        name: name.value,
        description: description.value,
        price: price.value,
      });

      // Ensure user is on the correct network
      if (networkMismatch) {
        switchNetwork?.(ChainId.Mumbai);
        return;
      }

      // Upload image using storage SDK
      const img = await sdk?.storage.upload(file);

      // Signature Mint NFT, get info (fetch generate mint signature)
      const req = await fetch("/api/generate-mint-signature", {
        method: "POST",
        body: JSON.stringify({
          address,
          name: e.target.elements.name.value,
          description: e.target.elements.description.value,
          image: img,
        }),
      });

      console.log({
        req: req.status + ":" + req.statusText
      });
      const signedPayload = (await req.json()).signedPayload;

      console.log({
        signedPayload: signedPayload
      });

      const nft = await nftCollection?.signature.mint(signedPayload);

      const mintedTokenId = nft?.id.toNumber();

      console.log({
        mintedTokenId: mintedTokenId
      });

      // Store the result of either the direct listing creation or the auction listing creation
      let transactionResult = undefined;

      console.log("Done");

      // Depending on the type of listing selected, call the appropriate function
      // For Direct Listings:
      // if (listingType.value === "directListing") {
      //   transactionResult = await createDirectListing(
      //     "0x5e0d08BF82f40b80DF1beb1874D04C1416BCc8B2",
      //     mintedTokenId,
      //     price.value
      //   );
      // }

      // For Auction Listings:
      // if (listingType.value === "auctionListing") {
      //   transactionResult = await createAuctionListing(
      //     "0x5e0d08BF82f40b80DF1beb1874D04C1416BCc8B2",
      //     mintedTokenId,
      //     price.value
      //   );
      // }

      // If the transaction succeeds, take the user back to the homepage to view their listing!
      if (transactionResult) {
        router.push(`/`);
      }
    } catch (error) {
      console.error(error);
      alert("Error creating listing. Check the console for more details");
    } finally {
      // setCreatingListing(false);
      console.log("finally");
    }
  }

  // const handleMintSubition = async (contract:SmartContract) => {
  //   try {
  //     contract.erc721.mint({
  //       name: name,
  //       // Image can be a File, or any url that points to a file.
  //       image: file,
  //       description: desc,
  //       properties: {
  //       // Add any properties you want to store on the NFT
  //       country:"Qatar",
  //       city: "Doha"
  //       }
  //   })

  //   } catch (error) {
  //     console.log(error);
  //   } finally {
  //     //setLoading(false)
  //   }//end try
  // };



  // const contractAddress="0x613239b4b2399e1bCC0D211F76a541CB136c3255"


  // const handleMint = async (contract:SmartContract) => {
  //   try {
  //     contract.erc721.mint({
  //       name: name,
  //       // Image can be a File, or any url that points to a file.
  //       image: file,
  //       description: desc,
  //       properties: {
  //       // Add any properties you want to store on the NFT
  //       country:"Qatar",
  //       city: "Doha"
  //       }
  //   })

  //   } catch (error) {
  //     console.log(error);
  //   } finally {
  //     //setLoading(false)
  //   }//end try
  // };



  return (



    <div className="bg-base-200 flex flex-col md:flex-row sm:flex-row place-items-start p-8 lg:p-16 md:p-12 sm:p-8">
      <form onSubmit={(e) => handleCreateListing(e)}>
        <div className="flex flex-col w-full lg:flex-row">
          {/* File Upload --------------------*/}
          <div className="grid grow h-max w-full lg:w-1/3 card bg-base-300 rounded-box place-items-start justify-start">
            <div className="cursor-pointer w-full bg-base-100 shadow-xl p-4">

              {file ? (

                <figure className="card">
                  <img alt="" src={URL.createObjectURL(file)} onClick={() => setFile(undefined)} />
                </figure>

              ) : (
                <div className="card inline-block items-center text-center align-middle w-full h-44 bg-base-200 text-base-200 p-8 border-dashed border-2 border-blue-600 ">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24" width="24" height="24"
                    className="mb-4 inline-block dark:fill-white"
                  >
                    <path fill="none" d="M0 0h24v24H0z" />
                    <path d="M16 13l6.964 4.062-2.973.85 2.125 3.681-1.732 1-2.125-3.68-2.223 2.15L16 13zm-2-7h2v2h5a1 1 0 0 1 1 1v4h-2v-3H10v10h4v2H9a1 1 0 0 1-1-1v-5H6v-2h2V9a1 1 0 0 1 1-1h5V6zM4 14v2H2v-2h2zm0-4v2H2v-2h2zm0-4v2H2V6h2zm0-4v2H2V2h2zm4 0v2H6V2h2zm4 0v2h-2V2h2zm4 0v2h-2V2h2z" />
                  </svg>
                  <p className="align-middle pb-4 mx-auto max-w-xs text-base text-gray-400">
                    Click here to upload a file
                  </p>
                  <p className="align-middle mx-auto max-w-xs text-xs text-gray-400">
                    Image, Video, or Audio file
                  </p>
                  <p className="align-middle  mx-auto max-w-xs text-xs text-gray-400">
                    max size: 1 GB
                  </p>
                  <FileUploader
                    handleChange={handleFileChange}
                    // ref={fileInputRef}
                    name="file"
                    types={fileTypes}
                    classes="file-drag cursor-pointer text-base-200"
                    label="."
                    // eslint-disable-next-line react/no-children-prop
                    children="."
                    maxSize={100}
                    minSize={0}
                  />
                </div>

              )}


              <div className="card-body">
                <h2 className="card-title">Shoes!</h2>
                <p>If a dog chews shoes whose shoes does he choose?</p>
                <div className="card-actions justify-end">
                  <button type="submit" className="btn btn-primary">mint</button>
                </div>
              </div>
            </div>
          </div>
          <div className="divider lg:divider-horizontal"></div>
          {/* Form ----------------------- */}
          <div className="grow flex h-max w-full lg:w-2/3 card bg-base-300 p-4 rounded-box place-items-start justify-start">

            {/* Name */}
            <div className="form-control w-full ">
              <label className="label w-full ">
                <span className="label-text">Name</span>
                <span className="label-text-alt">Alt label</span>
              </label>
              <input name="name" type="text" required maxLength={26} placeholder="Type here" className="input input-bordered w-full placeholder:text-gray-400" />
            </div>
            {/* Description */}
            <div className="form-control w-full">
              <label className="label">
                <span className="label-text">Description</span>
                <span className="label-text-alt">Alt label</span>
              </label>
              <textarea name="description" className="textarea textarea-bordered h-24 w-full" placeholder="Bio"></textarea>
            </div>
            {/*  */}
            <div className="form-control w-full">
              <label className="label">
                <span className="label-text">price?</span>
                <span className="label-text-alt">Alt label</span>
              </label>
              <input name="price" type="text" placeholder="Type here" className="input input-bordered w-full" />
            </div>
            {/*  */}
            <div className="form-control w-full">
              <label className="label">
                <span className="label-text">What is your name?</span>
                <span className="label-text-alt">Alt label</span>
              </label>
              <input type="text" placeholder="Type here" className="input input-bordered w-full" />
            </div>
            {/* mINT BUTTON */}
            <div className="card-actions justify-center my-10">
              <Web3Button
                // The contract address
                // contractAddress={ process.env.COLLECTION_QAFU_ADDRESS as string }
                contractAddress="0xdeAE77dc5C3784e83602AD8E7ae82124c6C58c04"
                // Access the contract itself, perform any action you want on it:
                action={async (contract) =>
                  contract.erc721.mint(
                    {
                      name: name,
                      // Image can be a File, or any url that points to a file.
                      image: file,
                      description: desc,
                      properties: {
                        // Add any properties you want to store on the NFT
                        country: "Qatar",
                        city: "Doha"
                      }
                    })
                }
                onError={(error) => { console.log(error) }}
                onSuccess={(result) => { console.log(result) }}
                onSubmit={() => { console.log("result") }}

                // Some customization of colors and styling
                className="btn btn-primary"
                colorMode="dark"
                accentColor="#8358FF"
              //accentColor="#F213A4"
              >
                Mint NFT
              </Web3Button>
            </div>
          </div>
        </div>
      </form>
    </div>
  );
};

// or getServerSideProps: GetServerSideProps<Props> = async ({ locale })
export const getStaticProps: GetStaticProps<Props> = async ({ locale }) => ({
  props: {
    ...await serverSideTranslations(locale ?? 'en', ['common', 'footer']),
  },
})

export default Create;

