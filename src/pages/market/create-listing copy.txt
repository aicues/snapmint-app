import {
    MediaRenderer,
    useNetwork,
    useNetworkMismatch,
    useListing,
    useContract,
    useCreateDirectListing,
    useCreateAuctionListing,
  } from "@thirdweb-dev/react";
  import {
    ChainId,
    ListingType,
    Marketplace,
    NATIVE_TOKENS,
    TransactionResultWithId,
  } from "@thirdweb-dev/sdk";
  import type { GetStaticProps, InferGetStaticPropsType, NextPage } from "next";
    import { serverSideTranslations } from "next-i18next/serverSideTranslations";
  import { useRouter } from "next/router";
  import { useState } from "react";
  // import { useMutation } from "@tanstack/react-query";

  import { getNftMetadata, Nft, NftTokenType } from "@alch/alchemy-sdk";
  import { alchemy } from "@config/alchemy";

import { NATIVE_TOKEN_ADDRESS } from "@thirdweb-dev/sdk";

  import useSWR from 'swr'
import NftCard from "@components/NftCard";
import Link from "next/link";



  type Props = {
    // Add custom props here
}

  const CreateListing: NextPage = (_props: InferGetStaticPropsType<typeof getStaticProps>) => {

    const router = useRouter();

    // De-construct listingId out of the router.query.
    // This means that if the user visits /listing/0 then the listingId will be 0.
    // If the user visits /listing/1 then the listingId will be 1.
    const { tokenId } = router.query as { tokenId: string };
    const { contractAddress } = router.query as { contractAddress: string };


    const fetcher = (tokenId: { toString: () => any; }) => 
        getNftMetadata(alchemy, {
            tokenId: tokenId?.toString() ?? "",
            contract: { address: contractAddress?.toString() ?? "" },
            tokenType: NftTokenType.ERC721,
      })
    .then(res => res)

    const { data, error } = useSWR(tokenId, fetcher)

    const nft = data as Nft;

    console.log("nft", nft);

    // Make
    // Initialize the marketplace contract
    const { contract: marketplace } = useContract( process.env.NEXT_PUBLIC_MARKETPLACE_CONTRACT_ADDRESS, "marketplace");

    console.log("marketplace", marketplace);

    const { mutateAsync: makeDirectListing } = useCreateDirectListing(marketplace);
    const { mutateAsync: makeAuctionListing } = useCreateAuctionListing(marketplace);

    const [price, setPrice] = useState<number>(0.01);
    const [minimumPrice, setMinimumPrice] = useState<number>(0.01);

    const options = [
      {value: 60 * 60 * 24 * 30, text: '-- Pick one --'},
      {value: 60 * 60 * 1 * 1, text: 'One Hour'},
      {value: 60 * 60 * 24 * 1, text: 'One Day'},
      {value: 60 * 60 * 24 * 7, text: 'One Week'},
     ];
    const [durationInSeconds, setDurationInSeconds] = useState<number>(options[0].value); // 1 week

    async function createAuctionListing(contractAddress:string, tokenId:string, price: number, minimumPrice: number, durationInSeconds: number) {
        try {
          console.log({contractAddress, tokenId, price, minimumPrice, durationInSeconds});
          makeAuctionListing(
            {
              assetContractAddress: contractAddress, // Contract Address of the NFT
              buyoutPricePerToken: price, // Maximum price, the auction will end immediately if a user pays this price.
              currencyContractAddress: NATIVE_TOKEN_ADDRESS, // NATIVE_TOKEN_ADDRESS is the crpyto curency that is native to the network. i.e. Goerli ETH.
              listingDurationInSeconds: durationInSeconds, //60 * 60 * 24 * 7, // When the auction will be closed and no longer accept bids (1 Week)
              quantity: 1, // How many of the NFTs are being listed (useful for ERC 1155 tokens)
              reservePricePerToken: minimumPrice, // Minimum price, users cannot bid below this amount
              startTimestamp: new Date(), // When the listing will start
              tokenId: tokenId, // Token ID of the NFT.
            },
            {
              onSuccess: (tx) => {
                // return tx;
                alert("Success! \n"+ tx.id);
                console.log("Success! \n"+ tx.receipt);
                router.push(`/market/${tx.id}`);
              },
            }
          );
        } catch (error) {
          console.error(error);
        }
      }


    const createAuctionListing2 = async () =>{

        return makeAuctionListing(
          {
            assetContractAddress: contractAddress, // Contract Address of the NFT
            buyoutPricePerToken: price, // Maximum price, the auction will end immediately if a user pays this price.
            currencyContractAddress: NATIVE_TOKEN_ADDRESS, // NATIVE_TOKEN_ADDRESS is the crpyto curency that is native to the network. i.e. Goerli ETH.
            listingDurationInSeconds: durationInSeconds, //60 * 60 * 24 * 7, // When the auction will be closed and no longer accept bids (1 Week)
            quantity: 1, // How many of the NFTs are being listed (useful for ERC 1155 tokens)
            reservePricePerToken: minimumPrice, // Minimum price, users cannot bid below this amount
            startTimestamp: new Date(), // When the listing will start
            tokenId: tokenId, // Token ID of the NFT.
          }
        );

    }

    async function createDirectListing(contractAddress:string, tokenId:string, price: number) {
        try {
            makeDirectListing(
            {
                assetContractAddress: contractAddress, // Contract Address of the NFT
                buyoutPricePerToken: price, // Maximum price, the auction will end immediately if a user pays this price.
                currencyContractAddress: NATIVE_TOKEN_ADDRESS, // NATIVE_TOKEN_ADDRESS is the crpyto curency that is native to the network. i.e. Goerli ETH.
                listingDurationInSeconds: 60 * 60 * 24 * 7, // When the auction will be closed and no longer accept bids (1 Week)
                quantity: 1, // How many of the NFTs are being listed (useful for ERC 1155 tokens)
                startTimestamp: new Date(0), // When the listing will start
                tokenId: tokenId, // Token ID of the NFT.
            },
            {
                onSuccess: (tx) => {
                return tx;
                },
            }
            );
        } catch (error) {
            console.error(error);
        }
    }

    async function create() {

      console.log({contractAddress, tokenId, price, minimumPrice, durationInSeconds});
      await createAuctionListing(contractAddress, tokenId, price, minimumPrice, durationInSeconds);
    }

    // const { mutate: create, isLoading } = useMutation({
    //   mutationFn: createAuctionListing,
    //   onError: (err: any) => {
    //     console.error(err);
    //     alert(err);
    //   },
    //   onSuccess: (txn: TransactionResultWithId) => {
    //     alert("Success! \n"+ txn.id);
    //     //router.push(`/listing/${txn.id}`);
    //   },
    // });


    return (
        <div className="bg-base-200 flex flex-col md:flex-row sm:flex-row place-items-start p-8 lg:p-16 md:p-12 sm:p-8">
            {/* Left Card: Image */}
            <div className="card h-max w-full lg:w-1/2 bg-base-300 rounded-box place-items-start justify-start">
                <div className="card w-full bg-base-100 p-6 shadow-xl place-items-center justify-center">
                <MediaRenderer
                    src={nft?.media[0].gateway}
                    style={{
                        // Fit the image to the container
                        width: "100%",
                        height: "100%",
                        borderRadius: 16,
                    }}
                />
                {/* <NftCard 
                image={nft?.media[0]?.gateway} 
                id={nft?.tokenId}
                description={nft?.description}
                title={nft?.title}
                contractAddress={nft?.contract.address}
                key={nft?.tokenId}>
                <></>
                </NftCard> */}

                </div>
            </div>
            <div className="divider lg:divider-horizontal"></div>
            {/* Right Card: Form fields */}
            <div className="card h-max w-full lg:w-1/2 bg-base-300 p-4 rounded-box place-items-start justify-start">
                <h1>{nft?.title} #{nft?.tokenId}</h1>
                <ul className="w-full">
                  {/* Price */}
                  <li key="price" className= "form-control w-full">
                    <label className="label w-full" htmlFor="price">
                        <span className="label-text">Price</span>
                        <span className="label-text-alt">{price}{"  "}⧫</span>
                    </label>
                    <input type="number" name="price"
                      min="0.05" max="10" step="0.05" value={price}
                      className="input w-full"
                      onChange={(e) => setPrice(Number(e.target.value))}/>
                  </li>
                  {/* Minimum Price */}
                  <li key="minmumPrice" className= "form-control w-full">
                    <label className="label w-full" htmlFor="minmumPrice">
                        <span className="label-text">Minimum Price</span>
                        <span className="label-text-alt">{minimumPrice}{"  "}⧫</span>
                    </label>
                    <input type="number" name="price"
                      min="0.05" max="10" step="0.05" value={minimumPrice}
                      className="input w-full"
                      onChange={(e) => setMinimumPrice(Number(e.target.value))}/>                   
                  </li>
                  {/* Duration */}
                  <li key="duration" className="form-control w-full">
                    <label className="label">
                      <span className="label-text">Auction Duration</span>
                      <span className="label-text-alt"></span>
                    </label>
                    <select value={durationInSeconds} className="select select-bordered"
                      onChange={(e) => setDurationInSeconds(Number(e.target.value))}>
                      {options.map(option => (
                        <option key={option.value} value={option.value}>
                          {option.text}
                        </option>
                      ))}
                    </select>
                  </li>
                  {/* Submit */}
                  <li key="submit" className="form-control w-full p-6">
                    <button className="btn btn-primary w-full" onClick={create}>List</button>
                  </li>
                </ul>
            </div>
            
            {/* <MediaRenderer
                src={data?.media[0].gateway}
                style={{
                    // Fit the image to the container
                    width: "100%",
                    height: "100%",
                    borderRadius: 16,
                }}
            /> */}

        </div>
    )

  }

  export const getStaticProps: GetStaticProps<Props> = async ({ locale }) => {
    const trans = await serverSideTranslations(locale ?? "en", ["common"]);
    return {
        props: {
            ...trans,
        },
    }
}

  export default CreateListing;